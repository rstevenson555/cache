/**
* This class contains the concrete implementation of the Most Recently Used Cache
* The cache is created from the Factory method createExpiringCache
**/
package com.bos.cache.impl;

import com.bos.cache.Cache;
import java.util.Iterator;

/**
* This is a implementation of a very fast MRU cache, the size of the cache
* is a fixed size determined at compile time, so we don't have to deal with growing
* and shrinking of the cache
* The Cache will tend to have items in it that are most often used and will
* throw out the Least Used Items
**/
class ExpiringMRUCacheImpl extends MRUCacheImpl implements Cache {
    // the initial size is 23 (prime) but you should change this to
    // fit your needs
    protected MRUEntry []cache = null;
    //  This cache will have a default expire time of 30 seconds;
    protected long expireTime = 1000*30;

    /**
     * This class maintains the key,value mapping
     **/
    private class MRUEntry implements java.util.Map.Entry
    {
        private Object value;
        private Object key;
        private long insertTime;
        private long lastTouchTime;
        private int touchCount;

        public MRUEntry(Object key,Object value)
        {
            this.key = key;
            this.value = value;
            insertTime=lastTouchTime=System.currentTimeMillis();
            touchCount=1;
        }
        public Object getKey() {
            return key;
        }
        public Object getValue() {
            return value;
        }
        public Object setValue(Object value)
        {
            this.value =  value;
            return this.value;
        }
        
        public long getStaleTime(){
            return System.currentTimeMillis() - insertTime;
        }

        public boolean equals(Object o)
        {
            MRUEntry other = (MRUEntry)o;
            return (getKey()==null ?  other.getKey()==null : getKey().equals(other.getKey()))  &&
			     (getValue()==null ?
			      other.getValue()==null : getValue().equals(other.getValue()));
        }

        /**
         * the hashCode is a xor of the key hashcode with the value hashcode
         **/
        public int hashCode()
        {
           return (getKey()==null ? 0 : getKey().hashCode()) ^
 			 (getValue()==null ? 0 : getValue().hashCode());
        }
    }

    /**
     * Contructor initialize the cache to the initial size of 23 (prime) placeholders
     * but you should change this to fit your needs
     * @see #setCacheSize(int size)
     **/
    public ExpiringMRUCacheImpl()
    {
        cache = new MRUEntry[23];
    }

     /**
     * Contructor initialize the cache to the specified size
     * @param size, the number of cache entries that the cache can maintain, should be a prime number
     * @see #setCacheSize(int size)
     **/
    public ExpiringMRUCacheImpl(int size)
    {
        cache = new MRUEntry[size];
    }
    
    public ExpiringMRUCacheImpl(int size, int expireSeconds){
        this(size);
        expireTime = (long)1000*expireSeconds;
    }

    /**
     * pre-allocates the size of this cache object
     * @param size allocates size cache entries
     * the size of the cache should be a prime-number, this allows a good
     * distribution of the keys across the span of the cache
     **/
    public void setCacheSize(int size)
    {
        cache = new MRUEntry[size];
    }

    /**
     * returns a cache key based on it's position in the cache
     * @return the Object placed at pos
     **/
    Object get(int pos)
    {
        return cache[pos];
    }

    /**
     * @param pos to element to remove
     **/
    void remove(int pos)
    {
        cache[pos] = null;
    }

    /**
     * returns the size of the mru cache table
     **/
    public int size()
    {
        return cache.length;
    }

    /**
     * Looks up an object and returns the value object found or null if the key is not found
     * @param key the value to look for
     **/
    public Object get(Object key)
    {
        MRUEntry obj = null;

        if ( key == null)
            return null;

        // lookup the key in the cache

        // synchronization is not a problem here
        // if someone changes or resets a key/value right before this
        // it will be properly handled, either it won't find a match in the if or the
        // obj being returned will be null, that is fine and expected for a no-match
        // then the client will just lookup whatever data he was looking for in the cache

        if ( (obj = cache[ Math.abs(key.hashCode()) % cache.length] )!=null ) {
            // see if the key passed in matches this one
            if ( obj.getKey().equals(key)){
                if(obj.getStaleTime() < expireTime){
                    return obj.getValue();
                }
            }
        }
        return null;
    }

    /**
     * clear resets any cache entries to null
     **/
    public void clear()
    {
        // synchronization is not a problem here
        // if this code were to be called while someone was getting or setting data
        // in the cache, it would still work
        // in the case of someone setting a value in the cache, then this coming along
        // and resetting the cache-entry to null is fine, because the client still has the data reference
        // in the case of someone getting a value from the cache while this is being reset
        // is fine as well because, if they get the data before it's set, they got it
        // if they as for it after it gets set to null, that's fine as well it's null and
        // that's a normal expected condition
		for(int i = 0;i<cache.length;i++)
			cache[i] = null;
    }

    /**
     * returns a iterator, to loop over all java.util.Map.Entry's in the cache
     **/
    public Iterator iterator()
    {
        java.util.Vector v = new java.util.Vector();
        for(int i=0; i<cache.length;++i){
            v.add(cache[i]);
        }
        return v.iterator();
    }


    /**
     * remove a reference to the given key
     * @param the key to lookup and remove
     **/
    public void remove(Object key)
    {
        if ( key == null)
            return;

        // find the place to put it and stuff it in, overwriting what was
        // previously there
        // synchronization is not needed here, if this value changes to null
        // either before or after a client looks at it, it's not a problem
        cache[ Math.abs(key.hashCode()) % cache.length] = null;
    }

    /**
     * Updates the cache with the key and value provided
     * @param key the key value used to lookup this value
     * @param value the value object associated with the given key
     **/
    public void put(Object key,Object value)
    {
        if ( key == null)
            return;

        // find the place to put it and stuff it in, overwriting what was
        // previously there
        cache[ Math.abs(key.hashCode()) % cache.length] = new MRUEntry(key,value);
    }
}
